//SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

//==============================================================================
//IMPORTS
//==============================================================================
import "lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";
import "lib/openzeppelin-contracts/contracts/access/AccessControl.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Permit.sol";
import "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/ERC20Burnable.sol";

/**
@title CyDyson
@notice This contract is used to create the CyDyson token that is used to represent future yield that is generated by the protocol
*/
contract CyDyson is ERC20, ERC20Permit, ERC20Burnable, AccessControl {
    //==============================================================================
    //STATE VARIABLES
    //==============================================================================
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    address[] public vaults;

    error VaultNotWhitelisted();

    modifier onlyWhitelistedVaults() {
        bool isWhitelisted = false;
        for (uint256 i = 0; i < vaults.length; i++) {
            if (vaults[i] == msg.sender) {
                isWhitelisted = true;
                break;
            }
        }
        if (!isWhitelisted) {
            revert VaultNotWhitelisted();
        }
        _;
    }

    //==============================================================================
    //CONSTRUCTOR
    //==============================================================================
    constructor() ERC20("cyDYSON", "CY_DYSON") ERC20Permit("CrossYield") {
        _grantRole(ADMIN_ROLE, msg.sender);
    }

    //==============================================================================
    //PUBLIC FUNCTIONS
    //==============================================================================
    /**
    @notice This function is used to mint tokens to a user
    @param _to The address of the user to mint tokens to
    @param _amount The amount of tokens to mint
    */
    function mint(address _to, uint256 _amount) public onlyWhitelistedVaults {
        _mint(_to, _amount);
    }

    /**
    @dev Burn tokens
    @param _from The address of the owner
    @param _amount The amount of tokens to burn
     */
    function burn(
        address _from,
        uint256 _amount
    ) external onlyWhitelistedVaults {
        burnFrom(_from, _amount);
    }

    /**
    @dev Add a vault to the whitelist
    @param _vault The address of the vault
    */
    function addVault(address _vault) external onlyRole(ADMIN_ROLE) {
        vaults.push(_vault);
    }

    /**
    @dev Remove a vault from the whitelist
    @param _vault The address of the vault
    */
    function removeVault(address _vault) external onlyRole(ADMIN_ROLE) {
        for (uint256 i = 0; i < vaults.length; i++) {
            if (vaults[i] == _vault) {
                vaults[i] = vaults[vaults.length - 1];
                vaults.pop();
                break;
            }
        }
    }
}
